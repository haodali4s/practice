{"ast":null,"code":"//detail模块的小仓库\n// import { reqDetailList, reqAddOrUpdateCart } from '@/api';\nimport { reqDetailList, reqAddOrUpdateCart } from '@/api';\nlet state = {\n  //商品详情的数据\n  detailInfo: {}\n};\nlet mutations = {\n  GETDETAILINFO(state, detailInfo) {\n    state.detailInfo = detailInfo;\n  }\n};\nlet actions = {\n  async getDetailInfo({\n    state,\n    commit,\n    dispatch\n  }, skuId) {\n    //商品详情请求，需要携带商品ID\n    let result = await reqDetailList(skuId);\n    if (result.code == 200) {\n      commit('GETDETAILINFO', result.data);\n    }\n  },\n  //加入购物车|将来修改商品个数的地方,右侧是载荷对象【两个K,两个V】\n  async addOrUpdateCart({\n    state,\n    commit,\n    dispatch\n  }, {\n    skuId,\n    skuNum\n  }) {\n    //底下即为：加入购物车(修改商品个数)的请求,参数顺序不能瞎写\n    let result = await reqAddOrUpdateCart(skuId, skuNum);\n    if (result.code == 200) {\n      //如果加入购物车成功,返回promise即为成功\n      return \"ok\";\n    } else {\n      //如果加入购物车失败，返回失败的Promise\n      return Promise.reject();\n    }\n    //思考问题:目的是前端把商品的ID、商品个数传递给服务器【人家服务器，兄弟我收到了,没有额外的给你传递其余的数据】\n    //想的问题:豪哥不对，咱们以前经常commit条件mutation存储数据【没有返回数据，没有数据可存储】,没有需要提交mutation让仓库\n    //存储数据\n    //第一种解决方案code,完全可以！！！！\n  }\n};\n//项目中仓库的getters为了简化数据而生【组件获取数据更加方便】\nlet getters = {\n  //面包屑的数据\n  categoryView(state) {\n    //研究这个问题:\n    //起始状态:state.detailInfo起始状态空对象,空对象.categoryView->undefined\n    //当服务器数据回来之后state.detailInfo,并非空对象,获取的即为服务器返回的数据{7个K}\n    //当前属性值:服务器的数据有值，用服务器的。服务器数据没有回来至少有一个空对象兜底【不能undefined兜底】\n    return state.detailInfo.categoryView || {};\n  },\n  //商品信息的数据\n  skuInfo() {\n    return state.detailInfo.skuInfo || {};\n  },\n  //商品销售属性列表的数据\n  spuSaleAttrList() {\n    return state.detailInfo.spuSaleAttrList || [];\n  }\n};\n\n//对外暴露\nexport default {\n  state,\n  mutations,\n  actions,\n  getters\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}