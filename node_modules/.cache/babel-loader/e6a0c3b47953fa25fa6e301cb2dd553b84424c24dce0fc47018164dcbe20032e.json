{"ast":null,"code":"//对于axios进行二次封装\nimport axios from \"axios\";\n//获取仓库:存储数据\nimport store from \"@/store\";\n// //引入进度条\nimport nprogress from 'nprogress';\n//引入相关进度条的样式\nimport \"nprogress/nprogress.css\";\n\n//axios.create方法执行,其实返回一个axios和request一样的\nlet requests = axios.create({\n  //基础路径,发请求URL携带api【发现:真实服务器接口都携带/api】\n  baseURL: \"/api\",\n  //超时的设置\n  timeout: 10000\n});\nlet requestsme = axios.create({\n  //基础路径,发请求URL携带api【发现:真实服务器接口都携带/api】\n  baseURL: \"/local\",\n  //超时的设置\n  timeout: 10000\n});\n\n//请求拦截器:将来项目中【N个请求】，只要发请求,会触发请求拦截器!!!\nrequests.interceptors.request.use(config => {\n  //请求拦截器:请求头【header】,请求头能否给服务器携带参数\n  //请求拦截器：其实项目中还有一个重要的作用,给服务器携带请求们的公共的参数\n  //进度条开始\n  nprogress.start();\n  if (store.state.shopcart.USER_ID) {\n    config.headers.userTempId = store.state.shopcart.USER_ID;\n  }\n\n  // //token[公共参数]\n\n  if (store.state.user.token) {\n    config.headers.token = store.state.user.token;\n  }\n\n  //每一次发请求,请求头携带用户临时身份\n  // config.headers.userTempId = SET_USERID();\n  //不管那个模块发请求,请求拦截器，都可以触发。请求拦截器可以通过请求头每一次协大公共参数给服务器【用户未登录的临时身份】\n  return config;\n});\n\n//响应拦截器：请求数据返回会执行\nrequests.interceptors.response.use(res => {\n  //res:实质就是项目中发请求、服务器返回的数据\n  //进度条结束\n  nprogress.done();\n  return res.data;\n}, err => {\n  //温馨提示:某一天发请求,请求失败,请求失败的信息打印出来\n  alert(err.message);\n  //终止Promise链\n  return new Promise();\n});\nrequestsme.interceptors.response.use(res => {\n  //res:实质就是项目中发请求、服务器返回的数据\n  //进度条结束\n  nprogress.done();\n  return res.data;\n}, err => {\n  //温馨提示:某一天发请求,请求失败,请求失败的信息打印出来\n  alert(err.message);\n  //终止Promise链\n  return new Promise();\n});\n//最后需要暴露:暴露的是添加新的功能的axios,即为requests\nexport { requests, requestsme };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}